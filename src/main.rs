#![no_std]
#![no_main]

use defmt::*;
use embassy_executor::Spawner;
use embassy_rp::{
    gpio::{Level, Output},
    spi::{self, Phase, Spi},
};
use embassy_time::Timer;
use {defmt_rtt as _, panic_probe as _};

enum Power {
    Active = 0,
    Down = 1,
}
enum AddressingMode {
    Horizontal = 0,
    Vertical = 1,
}

enum InstructionSet {
    Normal = 0,
    Extended = 1,
}

fn function_set(
    power: Power,
    addressing_mode: AddressingMode,
    instruction_set: InstructionSet,
) -> u8 {
    1 << 5 | (power as u8) << 3 | (addressing_mode as u8) << 2 | (instruction_set as u8)
}

enum DisplayControl {
    Blank = 0,
    AllSegmentsOn = 1,
    NormalMode = 4,
    InverseNode = 5,
}

/// Note: use only in Normal Mode
fn display_control(display_control: DisplayControl) -> u8 {
    1 << 3 | display_control as u8
}

/// Note: use only in Normal Mode
fn set_y(y: u8) -> u8 {
    1 << 6 | y
}

/// Note: use only in Normal Mode
fn set_x(x: u8) -> u8 {
    1 << 7 | x
}

/// Note: use only in Extended Mode
fn set_vop(vop: u8) -> u8 {
    1 << 7 | vop
}

fn char_to_bytes(char: char) -> &'static [u8] {
    match char {
        ' ' => &[0x00, 0x00, 0x00, 0x00, 0x00],
        '!' => &[0x00, 0x00, 0x5f, 0x00, 0x00],
        '"' => &[0x00, 0x07, 0x00, 0x07, 0x00],
        '#' => &[0x14, 0x7f, 0x14, 0x7f, 0x14],
        '$' => &[0x24, 0x2a, 0x7f, 0x2a, 0x12],
        '%' => &[0x23, 0x13, 0x08, 0x64, 0x62],
        '&' => &[0x36, 0x49, 0x55, 0x22, 0x50],
        '\'' => &[0x00, 0x05, 0x03, 0x00, 0x00],
        '(' => &[0x00, 0x1c, 0x22, 0x41, 0x00],
        ')' => &[0x00, 0x41, 0x22, 0x1c, 0x00],
        '*' => &[0x14, 0x08, 0x3e, 0x08, 0x14],
        '+' => &[0x08, 0x08, 0x3e, 0x08, 0x08],
        ',' => &[0x00, 0x50, 0x30, 0x00, 0x00],
        '-' => &[0x08, 0x08, 0x08, 0x08, 0x08],
        '.' => &[0x00, 0x60, 0x60, 0x00, 0x00],
        '/' => &[0x20, 0x10, 0x08, 0x04, 0x02],
        '0' => &[0x3e, 0x51, 0x49, 0x45, 0x3e],
        '1' => &[0x00, 0x42, 0x7f, 0x40, 0x00],
        '2' => &[0x42, 0x61, 0x51, 0x49, 0x46],
        '3' => &[0x21, 0x41, 0x45, 0x4b, 0x31],
        '4' => &[0x18, 0x14, 0x12, 0x7f, 0x10],
        '5' => &[0x27, 0x45, 0x45, 0x45, 0x39],
        '6' => &[0x3c, 0x4a, 0x49, 0x49, 0x30],
        '7' => &[0x01, 0x71, 0x09, 0x05, 0x03],
        '8' => &[0x36, 0x49, 0x49, 0x49, 0x36],
        '9' => &[0x06, 0x49, 0x49, 0x29, 0x1e],
        ':' => &[0x00, 0x36, 0x36, 0x00, 0x00],
        ';' => &[0x00, 0x56, 0x36, 0x00, 0x00],
        '<' => &[0x08, 0x14, 0x22, 0x41, 0x00],
        '=' => &[0x14, 0x14, 0x14, 0x14, 0x14],
        '>' => &[0x00, 0x41, 0x22, 0x14, 0x08],
        '?' => &[0x02, 0x01, 0x51, 0x09, 0x06],
        '@' => &[0x32, 0x49, 0x79, 0x41, 0x3e],
        'A' => &[0x7e, 0x11, 0x11, 0x11, 0x7e],
        'B' => &[0x7f, 0x49, 0x49, 0x49, 0x36],
        'C' => &[0x3e, 0x41, 0x41, 0x41, 0x22],
        'D' => &[0x7f, 0x41, 0x41, 0x22, 0x1c],
        'E' => &[0x7f, 0x49, 0x49, 0x49, 0x41],
        'F' => &[0x7f, 0x09, 0x09, 0x09, 0x01],
        'G' => &[0x3e, 0x41, 0x49, 0x49, 0x7a],
        'H' => &[0x7f, 0x08, 0x08, 0x08, 0x7f],
        'I' => &[0x00, 0x41, 0x7f, 0x41, 0x00],
        'J' => &[0x20, 0x40, 0x41, 0x3f, 0x01],
        'K' => &[0x7f, 0x08, 0x14, 0x22, 0x41],
        'L' => &[0x7f, 0x40, 0x40, 0x40, 0x40],
        'M' => &[0x7f, 0x02, 0x0c, 0x02, 0x7f],
        'N' => &[0x7f, 0x04, 0x08, 0x10, 0x7f],
        'O' => &[0x3e, 0x41, 0x41, 0x41, 0x3e],
        'P' => &[0x7f, 0x09, 0x09, 0x09, 0x06],
        'Q' => &[0x3e, 0x41, 0x51, 0x21, 0x5e],
        'R' => &[0x7f, 0x09, 0x19, 0x29, 0x46],
        'S' => &[0x46, 0x49, 0x49, 0x49, 0x31],
        'T' => &[0x01, 0x01, 0x7f, 0x01, 0x01],
        'U' => &[0x3f, 0x40, 0x40, 0x40, 0x3f],
        'V' => &[0x1f, 0x20, 0x40, 0x20, 0x1f],
        'W' => &[0x3f, 0x40, 0x38, 0x40, 0x3f],
        'X' => &[0x63, 0x14, 0x08, 0x14, 0x63],
        'Y' => &[0x07, 0x08, 0x70, 0x08, 0x07],
        'Z' => &[0x61, 0x51, 0x49, 0x45, 0x43],
        '[' => &[0x00, 0x7f, 0x41, 0x41, 0x00],
        '¥' => &[0x02, 0x04, 0x08, 0x10, 0x20],
        ']' => &[0x00, 0x41, 0x41, 0x7f, 0x00],
        '^' => &[0x04, 0x02, 0x01, 0x02, 0x04],
        '_' => &[0x40, 0x40, 0x40, 0x40, 0x40],
        '`' => &[0x00, 0x01, 0x02, 0x04, 0x00],
        'a' => &[0x20, 0x54, 0x54, 0x54, 0x78],
        'b' => &[0x7f, 0x48, 0x44, 0x44, 0x38],
        'c' => &[0x00, 0x38, 0x44, 0x44, 0x44, 0x20],
        'd' => &[0x00, 0x38, 0x44, 0x44, 0x48, 0x7f],
        'e' => &[0x00, 0x38, 0x54, 0x54, 0x54, 0x18],
        'f' => &[0x08, 0x7e, 0x09, 0x01, 0x02],
        'g' => &[0x0c, 0x52, 0x52, 0x52, 0x3e],
        'h' => &[0x7f, 0x08, 0x04, 0x04, 0x78],
        'i' => &[0x00, 0x44, 0x7d, 0x40, 0x00],
        'j' => &[0x20, 0x40, 0x44, 0x3d, 0x00],
        'k' => &[0x7f, 0x10, 0x28, 0x44, 0x00],
        'l' => &[0x00, 0x41, 0x7f, 0x40, 0x00],
        'm' => &[0x7c, 0x04, 0x18, 0x04, 0x78],
        'n' => &[0x00, 0x7c, 0x08, 0x04, 0x04, 0x78],
        'o' => &[0x00, 0x38, 0x44, 0x44, 0x44, 0x38],
        'p' => &[0x7c, 0x14, 0x14, 0x14, 0x08],
        'q' => &[0x08, 0x14, 0x14, 0x18, 0x7c],
        'r' => &[0x00, 0x7c, 0x08, 0x04, 0x04, 0x08],
        's' => &[0x48, 0x54, 0x54, 0x54, 0x20],
        't' => &[0x04, 0x3f, 0x44, 0x40, 0x20],
        'u' => &[0x3c, 0x40, 0x40, 0x20, 0x7c],
        'v' => &[0x1c, 0x20, 0x40, 0x20, 0x1c],
        'w' => &[0x3c, 0x40, 0x30, 0x40, 0x3c],
        'x' => &[0x44, 0x28, 0x10, 0x28, 0x44],
        'y' => &[0x0c, 0x50, 0x50, 0x50, 0x3c],
        'z' => &[0x44, 0x64, 0x54, 0x4c, 0x44],
        '{' => &[0x00, 0x08, 0x36, 0x41, 0x00],
        '|' => &[0x00, 0x00, 0x7f, 0x00, 0x00],
        '}' => &[0x00, 0x41, 0x36, 0x08, 0x00],
        '←' => &[0x10, 0x08, 0x08, 0x10, 0x08],
        '→' => &[0x78, 0x46, 0x41, 0x46, 0x78],
        '°' => &[0x00, 0x02, 0x05, 0x02, 0x00],
        _ => &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
    }
}

use AddressingMode::*;
use InstructionSet::*;

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_rp::init(Default::default());

    // External Reset Input
    let mut rst = Output::new(p.PIN_5, Level::Low);

    // Data / Command
    let mut dc = Output::new(p.PIN_4, Level::Low);

    // Data Input Serial Line
    // let mut din = Output::new(p.PIN_3, Level::Low);
    let din = p.PIN_3;

    // Serial Clock Time
    // let mut clk = Output::new(p.PIN_2, Level::Low);
    let clk = p.PIN_2;

    // Chip Enable
    let mut ce: Output<'_> = Output::new(p.PIN_1, Level::High);

    let mut config = spi::Config::default();
    config.frequency = 1_000_000;
    config.phase = Phase::CaptureOnFirstTransition;
    config.polarity = spi::Polarity::IdleLow;

    let mut spi = Spi::new_blocking_txonly(p.SPI0, clk, din, config);

    Timer::after_millis(5).await;
    let _light = Output::new(p.PIN_0, Level::Low);
    rst.set_high();
    ce.set_low();

    spi.blocking_write(&[
        function_set(Power::Down, Horizontal, Extended),
        // For some reason my screen does not switch to extended mode, so VOP (contrast),
        // bias and Temperature coeff can't be set.
        // set_vop(1 << 6),
        function_set(Power::Active, Horizontal, Normal),
        display_control(DisplayControl::NormalMode),
        // set_x(1),
        // set_y(1),
        function_set(Power::Active, Horizontal, Normal),
    ])
    .unwrap();

    dc.set_high();

    for c in "Weird screen".chars() {
        let glyph = char_to_bytes(c);
        spi.blocking_write(glyph).unwrap();
    }

    loop {
        Timer::after_secs(3).await;
    }
}
